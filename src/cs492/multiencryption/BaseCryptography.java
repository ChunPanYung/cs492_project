package cs492.multiencryption;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import java.io.*;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;


public class BaseCryptography {

	// Class variables
	static final SecureRandom RANDOM = new SecureRandom();
	private static final int COUNT = 1000;
	private static final byte[] SALT = {13, 99, 69};
	static final String ALGORITHM = "PBEWithHmacSHA256AndAES_256";


	public static String getAlgorithm() {
	 return ALGORITHM;
	}

	// Generate random number according to size
	// Output: randomly generated volume
	public static char[] randomZeroes (int size) {
		// Create array according to size
		char[] array = new char[size];


		// char variable for storing random char generated by SecureRandom() temporarily
		char pudding;
		// fill the array with random number
		for (int i = 0; i < size; i++) {
			// Generate a random int and put it into pudding
			pudding = (char) RANDOM.nextInt();
			// Put the current pudding into array[index]
			array[i] = pudding;
		}

		return array;
	} // end randomZeroes()

	// output a string as text file (UTF-16)
	public static void saveVolume(String input) throws IOException {
		// Specify FileOutputStream
		FileOutputStream outputStream = new FileOutputStream("Pudding.txt");
		// Specify encoding
		OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream, "UTF-16BE");
		// BufferedWriter
		BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter);

		// Write file
		bufferedWriter.write(input);
		// close file
		bufferedWriter.close();


	}

	// Read file content (UTF-16)
	public static ArrayList<Character> loadVolume(String fileName) throws IOException {
		// Specify input stream
		FileInputStream inputStream = new FileInputStream(fileName);
		// Specify encoding
		InputStreamReader reader = new InputStreamReader(inputStream, "UTF-16BE");

		// Read character one by one and print them out on screen
		int character;
		ArrayList<Character> arrChar = new ArrayList<Character>(100);
		while ( (character = reader.read()) != -1 ) {
			arrChar.add((char) character);
		}
		// close file reader
		reader.close();

		// return
		return arrChar;

	} // end loadVolume

	// Get random salt
	static byte[] getSalt() {
		// use SecureRandom to generate bytes
		byte[] retVal = new byte[16];
		RANDOM.nextBytes(retVal);

		return retVal;
	} // end getSalt()


	// Password hashing with salt
	static SecretKey passwordHash(char[] password)
		throws NoSuchAlgorithmException, InvalidKeySpecException {

		PBEKeySpec pbeKeySpec = new PBEKeySpec(password);
		SecretKeyFactory keyFac = SecretKeyFactory.getInstance(ALGORITHM);

		return keyFac.generateSecret(pbeKeySpec);
	} // end passwordHash()

	// Get random IV
	static IvParameterSpec getIV() {
		// use SecureRandom to generate bytes
		byte[] retVal = new byte[16];
		RANDOM.nextBytes(retVal);

		return new IvParameterSpec(retVal);
	} // end getIV()






	// Encrypt txt using PBE method with salt
	public static CryptoData encryptVolume(SecretKey key, CryptoData data,
	                                       byte[] salt)
	       throws InvalidAlgorithmParameterException, InvalidKeyException,
	       NoSuchPaddingException, NoSuchAlgorithmException,
	       BadPaddingException, IllegalBlockSizeException, IOException {

		PBEParameterSpec params = new PBEParameterSpec(salt, COUNT);

		// Encryption
		Cipher pbeCipher = Cipher.getInstance(ALGORITHM);
		pbeCipher.init(Cipher.ENCRYPT_MODE, key, params);

		return new CryptoData(pbeCipher.doFinal(data.getCryptoByte()), pbeCipher);

	} // end encryptVolume()

	// Get the parameter of encryption cipher
	// then convert it into AlgorithmParameters
	static AlgorithmParameters getEncryptCipher(SecretKey key, byte[] salt)
	        throws NoSuchPaddingException, NoSuchAlgorithmException,
	               InvalidAlgorithmParameterException, InvalidKeyException {

		PBEParameterSpec params = new PBEParameterSpec(salt, COUNT);
		// Encryption
		Cipher c = Cipher.getInstance(ALGORITHM);
		c.init(Cipher.ENCRYPT_MODE, key, params);

		return c.getParameters();
	} // end getEncryptCipher()

	/*
	   Decryption
	   Using the same PBEParameterSpec for decryption doesn't work
	   We will use different approach when it comes to decryption
	*/
	public static CryptoData decryptVolume(SecretKey key, CryptoData data,
	                                       byte[] salt)
	       throws NoSuchPaddingException, NoSuchAlgorithmException,
	              BadPaddingException, IllegalBlockSizeException, IOException,
	              InvalidAlgorithmParameterException, InvalidKeyException {

		AlgorithmParameters params;

		// if data.getParams() is null,
		if (data.getParams() == null) {
			params = getEncryptCipher(key, salt);
		} else { // else use data.params
			params = data.getParams();
		}

		// Specify algorithm
		Cipher pbeCipher = Cipher.getInstance(ALGORITHM);
		// Initializing it with PBE Cipher with key and parameters
		pbeCipher.init(Cipher.DECRYPT_MODE, key, params);

		return new CryptoData(pbeCipher.doFinal(data.getCryptoByte()), pbeCipher);
	} // end encryptVolume()

} // end class()
