package cs492.multiencryption;

import cs492.teaencryption.Tea;

import javax.crypto.*;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.io.*;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Base64;
import java.util.Collections;

import static cs492.multiencryption.CryptoUtil.stringToList;

public class BaseEncryption extends Tea {

	// Class variables
	private static final SecureRandom RANDOM = new SecureRandom();
	private static final int KEYLEN = 256;
	private static final byte[] SALT = {13, 99, 69};


	// Generate random number according to size
	// Output: randomly generated volume
	public static char[] randomZeroes (int size) {
		// Create array according to size
		char[] array = new char[size];


		// char variable for storing random char generated by SecureRandom() temporarily
		char pudding;
		// fill the array with random number
		for (int i = 0; i < size; i++) {
			// Generate a random int and put it into pudding
			pudding = (char) RANDOM.nextInt();
			// Put the current pudding into array[index]
			array[i] = pudding;
		}

		return array;
	} // end randomZeroes()

	// output a string as text file (UTF-16)
	public static void saveVolume(String input) throws IOException {
		// Specify FileOutputStream
		FileOutputStream outputStream = new FileOutputStream("Pudding.txt");
		// Specify encoding
		OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream, "UTF-16BE");
		// BufferedWriter
		BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter);

		// Write file
		bufferedWriter.write(input);
		// close file
		bufferedWriter.close();


	}

	// Read file content (UTF-16)
	public static ArrayList<Character> loadVolume(String fileName) throws IOException {
		// Specify input stream
		FileInputStream inputStream = new FileInputStream(fileName);
		// Specify encoding
		InputStreamReader reader = new InputStreamReader(inputStream, "UTF-16BE");

		// Read character one by one and print them out on screen
		int character;
		ArrayList<Character> arrChar = new ArrayList<Character>(100);
		while ( (character = reader.read()) != -1 ) {
			arrChar.add((char) character);
		}
		// close file reader
		reader.close();

		// return
		return arrChar;

	} // end loadVolume



	// Hashing password and return 256 bits (long[2])
	// Output long array
	static String passwordHash(char[] password) throws NoSuchAlgorithmException, InvalidKeySpecException {

		PBEKeySpec spec = new PBEKeySpec(password, SALT, Short.MAX_VALUE, KEYLEN);
		SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
		byte[] hash = keyFactory.generateSecret(spec).getEncoded();
		Base64.Encoder enc = Base64.getEncoder();

		// return String
		return enc.encodeToString(hash);
	}

	// Get the randomly generated salt
	// Package-private so we can test this method
	static byte[] getNextSalt() {
		// byte array
		byte[] salt = new byte[16];
		RANDOM.nextBytes(salt);

		// return salt
		return salt;
	}


	// Encrypt the text using Tea Encryption and hashed password
	// The length of hash is 44
	// It will use the method from Tea.java to encrypt the txt
	public static String encryptVolume(String plainText, String key) {

		try {
			Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
			cipher.init(Cipher.ENCRYPT_MODE, key);
			return Base64.getEncoder().encodeToString(cipher.doFinal(plainText.getBytes("UTF-8")));
		} catch (Exception e) {
			System.out.println("Error while encrypting: " + e.toString());
		} // end try...catch()

		return null;
	} // end encryptVolume()

	// Decrypt the text using Tea Encryption and hashed password
	// The length of hash is 44

	// It will use the method from Tea.java to encrypt the txt
	//
	public static ArrayList<Character> decryptVolume(char[] txt, String hash) {

		// Get the length of txt so it doesn't need to calculate twice
		int txtLen = txt.length;
		// Initialize the size of ArrayList the same size as txt
		ArrayList<Character> charList = new ArrayList<Character>(txtLen);

		// Variables for storing portion of char array (Pass it to encrypt())
		String cipherText;
		// Get portion of hash (first 32 characters only)
		String partHash = hash.substring(0, 32);


		for (int i = 0; i < txtLen; i += 16) {
			// Copy next 16-bit into plainText
			cipherText = Arrays.copyOfRange(txt, i, i + 15).toString();
			// Encrypt using plainText and partHash, then convert the string to
			// ArrayList
			charList.addAll(stringToList(decrypt(cipherText, partHash)));
		} // end for loop

		return charList;
	} // end encryptVolume()
} // end class()
