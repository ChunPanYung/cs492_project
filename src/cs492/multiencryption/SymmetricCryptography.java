package cs492.multiencryption;


import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.KeySpec;

/**
 * The BaseCryptography class will "stretch" the length of text, from 24 to 32,
 * after encryption.  For this reason, I write any class that extends it
 * (for code reuse) but use different method so it won't "stretch the length.
 */
public class SymmetricCryptography extends BaseCryptography {

	// This one is used to test different encryption
	// It outputs different length: from 24 to 32
	public static CryptoData encryptTry1(SecretKey key, CryptoData data)
	       throws NoSuchPaddingException, NoSuchAlgorithmException,
	              InvalidKeyException, BadPaddingException,
	              IllegalBlockSizeException {

		Cipher c = Cipher.getInstance(ALGORITHM);
		c.init(Cipher.ENCRYPT_MODE, key);

		return new CryptoData(c.doFinal(data.getCryptoByte()));

	} // end encryptVolume

	// Try another method with KeyGenerator
	public static CryptoData encryptTry2(CryptoData data)
	       throws NoSuchAlgorithmException, NoSuchPaddingException,
	              InvalidKeyException, BadPaddingException, IllegalBlockSizeException,
	              InvalidAlgorithmParameterException {

		// Generate key
		KeyGenerator keygen = KeyGenerator.getInstance("AES"); // AES algorithm
		keygen.init(256); // key size
		byte[] key = keygen.generateKey().getEncoded();
		SecretKeySpec skeySpec = new SecretKeySpec(key, "AES");

		// Generate IV
		byte iv[] = new byte[16];
		RANDOM.nextBytes(iv);
		IvParameterSpec randomIVSpec = new IvParameterSpec(iv);
		// Tested: this algorithm will give the same length of plaintext and ciphertext.
		Cipher c = Cipher.getInstance("AES/CTR/PKCS5Padding");
		c.init(Cipher.ENCRYPT_MODE, skeySpec, randomIVSpec);
		// return value
		return new CryptoData(c.doFinal(data.getCryptoByte()));
	}

	// Try another method with KeyGenerator
	// Gonna try it with EncryptTry3 method.
	// But this time, instead of randomly generate password,
	// it will use password generated by user
	public static CryptoData encryptTry3(CryptoData data, SecretKey key, byte[] iv)
					throws NoSuchAlgorithmException, NoSuchPaddingException,
					InvalidKeyException, BadPaddingException, IllegalBlockSizeException,
					InvalidAlgorithmParameterException {

		// Generate IV
		IvParameterSpec randomIVSpec = new IvParameterSpec(iv);

		// Tested: this algorithm will give the same length of plaintext and ciphertext.
		Cipher c = Cipher.getInstance("AES/CTR/PKCS5Padding");
		c.init(Cipher.ENCRYPT_MODE, key, randomIVSpec);
		// return value
		return new CryptoData(c.doFinal(data.getCryptoByte()));
	}

	// This is used for generating SecretKey based on password entered and salt
	static SecretKey passwordHash(char[] password, byte[] salt)
	       throws NoSuchAlgorithmException, InvalidKeySpecException {

		SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
		KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
		SecretKey tmp = factory.generateSecret(spec);

		return new SecretKeySpec(tmp.getEncoded(), "AES");

	}

}
